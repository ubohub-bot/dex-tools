#!/usr/bin/env python3
"""
dex-adb - Android device control via ADB

Usage:
  dex-adb devices                    List connected devices
  dex-adb connect <device>           Connect to device (phone/tablet or IP:port)
  dex-adb screenshot <device> [-o]   Take screenshot
  dex-adb info <device>              Device info
  dex-adb apps <device>              List installed apps
  dex-adb launch <device> <app>      Launch app (package name or alias)
  dex-adb open <device> <url>        Open URL in browser
  dex-adb notify <device> <text>     Show toast notification
  dex-adb shell <device> <cmd>       Run shell command
  dex-adb input <device> <text>      Type text
  dex-adb tap <device> <x> <y>       Tap screen coordinates
  dex-adb screen <device> on|off     Turn screen on/off
"""

import sys
import subprocess
import argparse
import json
import os
from datetime import datetime

# Known devices
DEVICES = {
    "phone": {"ip": "192.168.0.112", "name": "Motorola Edge 50 Neo"},
    "tablet": {"ip": "192.168.0.239", "port": "37203", "name": "Xiaomi Redmi Pad"},
    "nebula": {"ip": "192.168.0.248", "name": "Nebula Projector"},
}

# App aliases
APP_ALIASES = {
    "spotify": "com.spotify.music",
    "youtube": "com.google.android.youtube",
    "chrome": "com.android.chrome",
    "settings": "com.android.settings",
    "camera": "com.android.camera",
    "photos": "com.google.android.apps.photos",
    "telegram": "org.telegram.messenger",
    "whatsapp": "com.whatsapp",
}


def run_adb(args, capture=True):
    """Run ADB command"""
    cmd = ["adb"] + args
    if capture:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
        return result
    return subprocess.run(cmd, timeout=60)


def resolve_device(device_arg):
    """Resolve device alias to connection string"""
    if device_arg in DEVICES:
        dev = DEVICES[device_arg]
        port = dev.get("port", "5555")
        return f"{dev['ip']}:{port}", dev.get("name", device_arg)
    return device_arg, device_arg


def connect_device(device):
    """Connect to device via ADB"""
    conn_str, name = resolve_device(device)
    
    # Check if already connected
    result = run_adb(["devices"])
    if conn_str in result.stdout:
        return True, f"Already connected to {name}"
    
    # Try to connect
    result = run_adb(["connect", conn_str])
    if "connected" in result.stdout.lower():
        return True, f"Connected to {name} ({conn_str})"
    
    return False, f"Failed to connect: {result.stdout} {result.stderr}"


def list_devices():
    """List connected ADB devices"""
    result = run_adb(["devices", "-l"])
    lines = result.stdout.strip().split('\n')[1:]  # Skip header
    
    devices = []
    for line in lines:
        if line.strip():
            parts = line.split()
            if len(parts) >= 2:
                device_id = parts[0]
                status = parts[1]
                model = ""
                for p in parts[2:]:
                    if p.startswith("model:"):
                        model = p.split(":")[1]
                devices.append({"id": device_id, "status": status, "model": model})
    
    return devices


def take_screenshot(device, output_path=None):
    """Take screenshot from device"""
    conn_str, name = resolve_device(device)
    
    # Ensure connected
    connect_device(device)
    
    if output_path is None:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_path = f"/tmp/android_{timestamp}.png"
    
    # Capture on device
    remote_path = "/sdcard/screenshot.png"
    result = run_adb(["-s", conn_str, "shell", "screencap", "-p", remote_path])
    
    if result.returncode != 0:
        return None, f"Capture failed: {result.stderr}"
    
    # Pull to local
    result = run_adb(["-s", conn_str, "pull", remote_path, output_path])
    
    if result.returncode != 0:
        return None, f"Pull failed: {result.stderr}"
    
    # Cleanup remote
    run_adb(["-s", conn_str, "shell", "rm", remote_path])
    
    return output_path, None


def get_device_info(device):
    """Get device information"""
    conn_str, name = resolve_device(device)
    connect_device(device)
    
    props = ["ro.product.model", "ro.product.brand", "ro.build.version.release", 
             "ro.build.version.sdk", "ro.product.device"]
    
    info = {"name": name, "connection": conn_str}
    
    for prop in props:
        result = run_adb(["-s", conn_str, "shell", "getprop", prop])
        if result.returncode == 0:
            key = prop.split(".")[-1]
            info[key] = result.stdout.strip()
    
    # Battery
    result = run_adb(["-s", conn_str, "shell", "dumpsys", "battery"])
    if result.returncode == 0:
        for line in result.stdout.split('\n'):
            if 'level:' in line:
                info['battery'] = line.split(':')[1].strip() + '%'
    
    return info


def launch_app(device, app):
    """Launch app on device"""
    conn_str, name = resolve_device(device)
    connect_device(device)
    
    # Resolve alias
    package = APP_ALIASES.get(app.lower(), app)
    
    result = run_adb(["-s", conn_str, "shell", "monkey", "-p", package, 
                      "-c", "android.intent.category.LAUNCHER", "1"])
    
    return result.returncode == 0


def open_url(device, url):
    """Open URL on device"""
    conn_str, name = resolve_device(device)
    connect_device(device)
    
    result = run_adb(["-s", conn_str, "shell", "am", "start", 
                      "-a", "android.intent.action.VIEW", "-d", url])
    
    return result.returncode == 0


def show_toast(device, text):
    """Show toast notification (requires termux or root)"""
    conn_str, name = resolve_device(device)
    connect_device(device)
    
    # Try via am broadcast (might need special app)
    result = run_adb(["-s", conn_str, "shell", "am", "broadcast", 
                      "-a", "android.intent.action.SHOW_TOAST",
                      "--es", "message", text])
    
    return result.returncode == 0


def run_shell(device, cmd):
    """Run shell command on device"""
    conn_str, name = resolve_device(device)
    connect_device(device)
    
    result = run_adb(["-s", conn_str, "shell"] + cmd.split())
    return result.stdout, result.stderr, result.returncode


def input_text(device, text):
    """Type text on device"""
    conn_str, name = resolve_device(device)
    connect_device(device)
    
    # Escape spaces
    escaped = text.replace(" ", "%s")
    result = run_adb(["-s", conn_str, "shell", "input", "text", escaped])
    return result.returncode == 0


def tap_screen(device, x, y):
    """Tap screen at coordinates"""
    conn_str, name = resolve_device(device)
    connect_device(device)
    
    result = run_adb(["-s", conn_str, "shell", "input", "tap", str(x), str(y)])
    return result.returncode == 0


def screen_power(device, state):
    """Turn screen on/off"""
    conn_str, name = resolve_device(device)
    connect_device(device)
    
    if state.lower() == "on":
        result = run_adb(["-s", conn_str, "shell", "input", "keyevent", "KEYCODE_WAKEUP"])
    else:
        result = run_adb(["-s", conn_str, "shell", "input", "keyevent", "KEYCODE_SLEEP"])
    
    return result.returncode == 0


def main():
    parser = argparse.ArgumentParser(
        description="Android device control via ADB",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    
    parser.add_argument("command", help="Command to run")
    parser.add_argument("args", nargs="*", help="Command arguments")
    parser.add_argument("-o", "--output", help="Output path for screenshots")
    parser.add_argument("--json", action="store_true", help="JSON output")
    parser.add_argument("--show", action="store_true", help="Open screenshot after capture")
    
    args = parser.parse_args()
    cmd = args.command.lower()
    
    # List devices
    if cmd == "devices":
        devices = list_devices()
        if args.json:
            print(json.dumps(devices, indent=2))
        else:
            print("üì± Connected devices:")
            if not devices:
                print("   (none)")
            for d in devices:
                status_icon = "‚úÖ" if d["status"] == "device" else "‚ùå"
                print(f"   {status_icon} {d['id']} - {d['model'] or 'unknown'} ({d['status']})")
            print("\n   Aliases: phone (Motorola), tablet (Xiaomi)")
    
    # Connect
    elif cmd == "connect":
        if not args.args:
            print("‚ùå Usage: dex-adb connect <device>")
            sys.exit(1)
        success, msg = connect_device(args.args[0])
        print(f"{'‚úÖ' if success else '‚ùå'} {msg}")
        sys.exit(0 if success else 1)
    
    # Screenshot
    elif cmd == "screenshot" or cmd == "ss":
        if not args.args:
            print("‚ùå Usage: dex-adb screenshot <device>")
            sys.exit(1)
        print(f"üì∏ Capturing...", end=" ", flush=True)
        path, error = take_screenshot(args.args[0], args.output)
        if error:
            print(f"‚ùå {error}")
            sys.exit(1)
        print(f"‚úÖ")
        print(f"   Saved: {path}")
        if args.show:
            subprocess.run(["open", path])
    
    # Info
    elif cmd == "info":
        if not args.args:
            print("‚ùå Usage: dex-adb info <device>")
            sys.exit(1)
        info = get_device_info(args.args[0])
        if args.json:
            print(json.dumps(info, indent=2))
        else:
            print(f"üì± {info.get('name', 'Device')}:")
            for k, v in info.items():
                if k != 'name':
                    print(f"   {k}: {v}")
    
    # Launch app
    elif cmd == "launch":
        if len(args.args) < 2:
            print("‚ùå Usage: dex-adb launch <device> <app>")
            print(f"   Aliases: {', '.join(APP_ALIASES.keys())}")
            sys.exit(1)
        if launch_app(args.args[0], args.args[1]):
            print(f"üöÄ Launched {args.args[1]}")
        else:
            print(f"‚ùå Failed to launch {args.args[1]}")
            sys.exit(1)
    
    # Open URL
    elif cmd == "open":
        if len(args.args) < 2:
            print("‚ùå Usage: dex-adb open <device> <url>")
            sys.exit(1)
        if open_url(args.args[0], args.args[1]):
            print(f"üåê Opened URL")
        else:
            print(f"‚ùå Failed to open URL")
            sys.exit(1)
    
    # Shell
    elif cmd == "shell":
        if len(args.args) < 2:
            print("‚ùå Usage: dex-adb shell <device> <command>")
            sys.exit(1)
        stdout, stderr, code = run_shell(args.args[0], ' '.join(args.args[1:]))
        if stdout:
            print(stdout)
        if stderr:
            print(stderr, file=sys.stderr)
        sys.exit(code)
    
    # Input text
    elif cmd == "input" or cmd == "type":
        if len(args.args) < 2:
            print("‚ùå Usage: dex-adb input <device> <text>")
            sys.exit(1)
        if input_text(args.args[0], ' '.join(args.args[1:])):
            print(f"‚å®Ô∏è Text entered")
        else:
            print(f"‚ùå Failed")
            sys.exit(1)
    
    # Tap
    elif cmd == "tap":
        if len(args.args) < 3:
            print("‚ùå Usage: dex-adb tap <device> <x> <y>")
            sys.exit(1)
        if tap_screen(args.args[0], args.args[1], args.args[2]):
            print(f"üëÜ Tapped ({args.args[1]}, {args.args[2]})")
        else:
            print(f"‚ùå Failed")
            sys.exit(1)
    
    # Screen
    elif cmd == "screen":
        if len(args.args) < 2:
            print("‚ùå Usage: dex-adb screen <device> on|off")
            sys.exit(1)
        if screen_power(args.args[0], args.args[1]):
            print(f"üì± Screen {args.args[1]}")
        else:
            print(f"‚ùå Failed")
            sys.exit(1)
    
    else:
        print(f"‚ùå Unknown command: {cmd}")
        print("Commands: devices, connect, screenshot, info, launch, open, shell, input, tap, screen")
        sys.exit(1)


if __name__ == "__main__":
    main()
